
/*
题目描述：
给定一个十进制整数N,求出从1到N的所有整数中出现”1”的个数。
      例如：N=2，1,2出现了1个“1”。
            N=12，1,2,3,4,5,6,7,8,9,10,11,12。出现了5个“1”。
分析：
我们分析1~N中的数在每一位上出现1的次数的和，看看每一位上“1”出现的个数的和由什么决定。

       1位数的情况：

       大于等于1的时候，有1个，小于1就没有。

       2位数的情况：

       N=13,个位数出现的1的次数为2，分别为1和11，十位数出现1的次数为4，分别为10,11,12,13，所以f(N) = 2+4。

       N=23,个位数出现的1的次数为3，分别为1，11，21，十位数出现1的次数为10，分别为10~19，f(N)=3+10。

由此我们发现，个位数出现1的次数不仅和个位数有关，和十位数也有关，如果个位数大于等于1，则个位数出现1的次数为十位数的数字加1；如果个位数为0，个位数出现1的次数等于十位数数字。而十位数上出现1的次数也不仅和十位数相关，也和个位数相关：如果十位数字等于1，则十位数上出现1的次数为个位数的数字加1，假如十位数大于1，则十位数上出现1的次数为10。

       3位数的情况:

       N=123

       个位出现1的个数为13:1,11,21，…，91,101,111,121

       十位出现1的个数为20:10~19,110~119

       百位出现1的个数为24:100~123

       我们可以继续分析4位数，5位数，推导出下面一般情况：

       假设N，我们要计算百位上出现1的次数，将由三部分决定：百位上的数字，百位以上的数字，百位一下的数字。

       如果百位上的数字为0，则百位上出现1的次数仅由更高位决定，比如12013，百位出现1的情况为100~199,1100~1199,2100~2199，…，11100~11199，共1200个。等于更高位数字乘以当前位数，即12 * 100。

       如果百位上的数字大于1，则百位上出现1的次数仅由更高位决定，比如12213，百位出现1的情况为100~199,1100~1199,2100~2199，…，11100~11199，12100~12199共1300个。等于更高位数字加1乘以当前位数，即（12 + 1）*100。

        如果百位上的数字为1，则百位上出现1的次数不仅受更高位影响，还受低位影响。例如12113，受高位影响出现1的情况：100~199,1100~1199,2100~2199，…，11100~11199，共1200个，但它还受低位影响，出现1的情况是12100~12113，共114个，等于低位数字113+1。
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>

int numOfOne(int N)
{
  int count = 0;
  int factor = 1;
  int lowNum = 0;
  int highNum = 0;
  int curNum = 0;

  while(N/factor != 0)
  {
    curNum = (N/factor)%10;
    lowNum = N - (N/factor)*factor;
    highNum = N/(factor*10);
    switch(curNum)
    {
      case 0 :
        count += highNum * factor;
        break;
      case 1 :
        count += highNum * factor + lowNum + 1;
        break;
      default :
        count += (highNum + 1) * factor;
        break;
    }

    factor = factor*10;
  }
  return count;
}

int main(int args,char ** argv)
{
  int N = 12;
  int res = numOfOne(N);
  std::cout<<res<<std::endl;
  system("pause");
  return 0;
}























