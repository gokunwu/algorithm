
/*
copyright@nciaebupt 转载请注明出处
题目：已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，使得它构造0和1的概率均为1/2；构造一个发生器，使得它构造1、2、3的概率均为1/3；...，构造一个发生器，使得它构造1、2、3、...n 的概率均为1/n，要求复杂度最低。
首先是1/2的情况，我们一次性生成两个数值，如果是00或者11丢弃，否则留下，01为1，10为0，他们的概率都是p*(1-p)是相等的，所以等概率了。
然后是1/n的情况了，我们以5为例，此时我们取x=2，因为C(2x,x)=C(4,2)=6是比5大的最小的x，此时我们就是一次性生成4位二进制，把1出现个数不是2的都丢弃，这时候剩下六
个:0011,0101,0110,1001,1010,1100，取最小的5个，即丢弃1100，那么我们对于前5个分别编号1到5，这时候他们的概率都是p*p*(1-p)*(1-p)相等了。
关键是找那个最小的x，使得C(2x,x)>=n这样能提升查找效率。

因为C(n,i)最大是在i接近n/2的地方取得，此时我有更大比率的序列用于生成，换句话说被抛掉的更少了，这样做是为了避免大量生成了丢弃序列而使得生成速率减慢，实际上我之所以将x取定是为了让我取得的序列生成的概率互相相等，比如C(2x,x)的概率就是[p(1-p)]^x，互等的样例空间内保证了对应的每个值取得的样例等概率。

使用已知的随机发生器构造n个数，则其中有k个1的概率是n!/(k!*(n-k)!)*p^k*(1-p)^(n-k)


腾讯面试题:

已知有个rand7()的函数，返回1到7随机自然数，让利用这个rand7()构造rand10() 随机1~10。

利用的方法和上个问题类似，如何能够得到一个等概率的独立事件。这个问题和上个问题不同的是，这里产生的序列，要变成和的形式或者其他的形式，那么概率就会发生变化了。

如果能够得到一组等概率的数，不管是什么数，只要等概率而且个数大于10，那么问题就可以解决了。

发现(rand7()-1)*7+rand7(),可以等概率的生成1到49。

呵呵，这不就得了，只要把11-49砍掉就可以了。不过这样的效率比较低。可以砍掉41-49，然后在把1-40映射到1-10，那么问题也就解决了。

腾讯面试题:

等概率采样数据流中的数字。

比如从数据流中等概率的采样k个数字。

怎么做呢？先拿到最开始的k个数字，然后以后的每个数字等概率的和这k个数字交换。那么就可以达到每个数字被抽取的概率是等概率的。

怎么证明呢？

采用归纳方法，假设前n个数字等概率的采样k个数字，那么每个数字被采样的概率为k/n,现在新来一个数字，变成了n+1个数字，那么每个数字被采样的概率变位k/(n+1),我们要证明这个

这个问题在计算机程序设计艺术书中提到，叫Reservoir Sampling（蓄水池采样），属于随机算法的一种。

现在假定存在了n个数字，来了第n+1个数字，那么第n+1个数字被选择的概率是k/n+1,那么我们推算其他的数字被选择的概率也是k/n+1

P(其余数字) = p(其余数字|第n+1个选择)*p(第n+1个选择) + p(其余数字|第n+1个不选择)*p(第n+1个不选择)

                      =  k/n*(1-1/k)*k/(n+1) + k/n*(n+1-k)/(n+1)

                      = k*(k-1) / (n *(n+1) ) + k*(n+1-k) / (n*(n+1))

                      = k*n/(n *(n+1))

                      = k/(n+1)

得证。其余数字被选择的概率依然也是 k/(n+1)
*/
